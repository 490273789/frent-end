# 复杂度

> 算法设计最求的两个目标 - 找到解决问题的方法 - 从多个方法中寻求最优解

## 算法效率的评估的两个维度

- 时间效率：算法运行速度的快慢
- 空间效率：算法占用内存空间的大小

## 迭代与递归

如果我们重复执行某个任务，通常会选用两个基本的程序结构 - **迭代与递归**

### 迭代

迭代 - iteration 重复执行某个任务的控制结构，程序会在满足一定条件的情况下重复执行某段代码  

#### for循环

常见的迭代形式之一，**适用于预先知道迭代次数时使用**  

举例：求和 1+2+3+4+...+n

```javaScript
const forLoop = (n) => {
  let result = 0
  for(let i = 1; i <= n; i++) {
    result += i
  }
  return result
}

```

#### while循环

常见的迭代形式之一，自由度会比for循环高一些

举例：求和 1+2+3+4+...+n

```javaScript
const whileLoop = (n) => {
  let result = 0
  let i = 1
  while(i <= n) {
    result += i++
  }
  return result
}

```

#### 嵌套循环

双层for循环  

这种情况下算法的复杂度与n²成正比，有几层for循环复杂度就是n几次方

```javaScript
const nestedForLoop = (n) => {
  let result = 0
  for(let i = 1; i <= n; i++) {
    for(let j = 1; j <= n; j++) {
      result += `(${i}, ${j}), `
    }
  }

  return result
}
```

#### 递归 - recursion

是一种算法策略，通过调用函数自身来解决问题，主要包含两个阶段

1. 递：程序不断的深入调用自身，通过输入更小或更简化的参数，直到达到终止条件（出口）
2. 归：触发终止条件后，程序从最深层次的递归函数开始逐层返回，汇聚每一层的结果

从实现的角度来看，递归代码主要包含三个要素。

1. 终止条件：用于决定递转归
2. 递归调用：对应“递”，函数调用自身，通常输入更小或更简化的参数
3. 返回结果：对应“归”，将当前递归层级的结果返回上一层

```javaScript
const recur = (n) => {
  if(n === 1) return 1
  const result = recur(n - 1)
  return n + result
}
```

### 递归和迭代总结

两种方法都可以得到相同结果，但是他们代表了两种完全不同的思考和解决问题的范式  

- 迭代：自下而上的解决问题，从醉基础的步骤开始，然后不断的重复或累加这些步骤，直到任务完成。
- 递归：自上而下的解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，知道基本情况时停止（基本情况的解是已知的）。

以上面的求和为例：

- 迭代：在循环模拟过程中，从1遍历到n，每轮执行求和操作，即可求得f(n)。
- 递归：将问题分解为子问题f(n) = f(n) + f(n-1)，不断地（递归）分解下去，直至基本情况f(0) = 0。

调用栈 - 递归每次调用自身时，系统都会为其新开启函数分配内存，以存储局部变量、调用栈和其他信息。浙江导致以下结果：

- 函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，**递归通常比迭代更加耗费内存空间**。
- 递归调用函数会产生额外的开销。**因此递归通常比循环的时间效率更低**。
- 在实际中，编程语言允许的递归深度通常是有限的，过深的递归可能导致栈溢出报错。

#### 尾递归 - tail recursion

**如果在函数返回前的最后一步才进行递归调用**，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当（但是不是所有的编译器都支持尾递归）。这种情况呗成为尾递归。

- 普通递归： 当函数返回上一层的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文
- 尾递归：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无需继续执行其他操作，因此系统无需保存上层函数的上下文

尾递归实现求和：

```javaScript
const tailRecursion = (n, result) => {
  if(n === 0) result
  return tailRecursion(n - 1, result + n)
}
```

- 普通递归：是在“归”的过程中实现求和的。
- 尾递归：实在“递”的过程中实现求和的。

#### 递归树

当处理与“分治”思想相关的算法问题时，递归往往比迭代的思路更加直观、易读。以“斐波那契数列”为例：

```javaScript
const fib = (n) => {
  if(n === 1) return 0
  if(n === 2) return 1
  return fib(n - 1) + fib(n - 2)
}
```

本质上看，递归体现“将问题分解为更小子问题”的思维范式，这种分治策略是至关重要的。

- 从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略都直接或间接地应用这种思维方式。
- 从数据结构角度看，递归天然适合处理链表、树和图的相关问题，因为它们非常适合用分治思想进行分析。

递归转换为迭代 - **使用一个显示的栈来模拟调用栈的行为**

```javaScript
 const forLoopRecur = (n) => {
  let result = 0;
  const stack = []
  // “递”的过程，入栈操作
  for(let i = 0; i <= n; i++) {
    stack.push(i)
  }
  // “归”的过程，出栈操作
  while(stack.length) {
    result += stack.pop()
  }
  return result
}
```
